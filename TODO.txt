IMPORTING/SYSTEM TASKS:
	- failing import/dynamic par/zn/aux count

  - new/simpler switching model?

	- script/path cleanup
	- merge paths into par/zn

	- asynchronous compiling
	- after first script updates tree, stop executing scripts






MAJOR FEATURES
  - compiler performance
	  - best idea right now is to compile over multiple frames
		- problem with that is that moduleRefPool changes before compilation is complete
		- SO:
		  - consider compilation asynchronous?
		- also, batch compilation?  only happens once every n ms?

  - async asset loading?
	  - what do we do when we dont have the asset yet?
		- which images are loaded?

	- importing
	  - we have the modRefPool, which is local references to library modules.
		  - everything here is in the state tree(until things get asynchronous)
		- how about we have to import a module into a specific place
		  - insted of importing & then sticking it somewhere
	  - various imports, MODULE:
		  - incMod - get module from library
			- incSub - clone module, but with new sub from sub library
			- incScript - clone module, new script from scr library
			- incImage - clone module, new image from img library
		- various imports, SCRIPT:
		  - we parse scripts from txt -> data, so they can have state
			- we import them, so our modules have references instead of actual objects
			  - is this smart?
				- should be fine
		- importing can FAIL?
		  - to many variables?
			- tree too big
    - this -10000(for random), etc shit is ghetto
		- MISC
		  - module.modules should be [SubModule = SubLib String | SubPool String] or something
      - module/submodule cycles??
	  - RELATIONSHIP BETWEEN IMPORT & COMPILE
		  - right now import => immediate recompile
			- assume recompile is asynchronous
			- keep using old modRefPool until compilation done?  do we really need to clone the pool?
			  - then switch out pool & shader when compilation is done
				- what about additional imports while compiling? do they affect new or old tree?
				- stop all imports until compile done? imports currently only happen from scripts or UI?


	- restructure data
	  - scripts inlined
		  - parsed to data with state
			- maintain phases when switching
		- bundle paths & variables? - ie a variable is always on a path, sometimes its just static?
		- modules are instances of components - specific values for variables & scripts
		- components are instances of families.
		  - contain code
			- variable specifications ie how many par, how many images, & default values
		- families are variable names & dimensions.  basically where this object fits.
		- scripts could use some more thought.
		  - which module do they belong to?
			- how to syncronize multiple scripts? i.e, color & disp?

	- database support
	  - which database?
		- how are things stored/serialized?
		- search by family, component, flags, props, id
		- what about things like libName?
		- sync local & remote dbs

	- UI
	  - basic idea is that all db & data modifications happen through UI
		- but we need to completely rework how the ui happens.
		  - dont want to have to pause to update tree, that's kind of ghetto
			- individually pause paths/modules?


POST FARM:
  - clean up after farm
	  - clean up main

	- REFACTOR UI - its super ghetto now
		- make ui reactive to pattern/ui conf, etc?
	  - no more text files. entirely done via web - patterns, scripts config, etc

	- move everything to a database
	  - put textures there too?
		- update flags on save (default != true)
  	- check for duplicates when saving (id = hash of contents?)
	  - next config/library pass (maybe better error detection)
    - namespace collision in modules.lib?

  - just release it?
  - kickstarter for audio responsiveness?
	  - make main pattern a little better




NEXT 2
 SYSTEM
	- patternRefPool?
  - make patterns modules/pattern level scripts?

	- put pattern into systemST, patternRefPool.  remove createScript & stop passing pattern around
	- interpolating between patterns?
  - findParent is kind of ghetto
  - ModRef used inconsistiently


BUGS:
	- complex parsing - currently need both components i.e 0.0 + 1.3i
  - catch errors when parsing t_exp
  - no error message when image texture doesnt exist
  - reduce is a substition in seeds, but comes from appliction.  the order of "modules {x: .., y: ..}" matters :/
  - if there are too many aux buffers (texture units), we'll have an issue?
  - on windows menu disappears hovering over res selector
  - weird when opening console in fullscreen
  - shader indentation issues with switching & in general
  - error handling for failing to enter fullscreen mode
  - number parsing flakey? how so?

PERF:
  - zoom out performance problem.  unclear what the deal is.  really bad with 1/z
	- chopiness when at higher resolutions
  - choppy in safari
  - switch stuttering. it's compile speed + texutre upload

SYSTEM:
  - scripts
    - way of switching modules while keeping phase/scripts.
	  - keep scripts when switching modules?
  - javascript files are all over the place
	- fract a sub on main body set in engine before compiling?
  - use git for deploy
  - addGlobalEventListeners is a bit ghetto
  - more work on fract.  more specific fracts.  like for seed vs T.  can possibly also increase quality
	- too many debug statements going on (in engine?)
  - prevent default in ui.js
  - make serializable a class
  - detect system/perf profile
  - remote control (webui, websockets, etc)
  - currently manually implementing GL.repeat for aux
  - compiler substitutions %XXXX%, etc can still cause errors?  dont remember what kind
  - investigate dsl for scripts
  - engine stability/lost context - https://www.khronos.org/registry/webgl/extensions/WEBGL_lose_context/
  - main & disp share includes
  - preprocesser malfunctions give weird errors
	- https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_shaders/
  - scripts conflicting with each other?  who has priority
  - better data organization
	  - merge configs & states?
		- what goes in config, what goes into states?
		- put ref pools in pattern? why did I think of that?
  - better engine error checking/handling

FEATURE IDEAS:
  - blend maps!! variable interpolation
	- catagorize transformations:
  	- symmetries, is_inversion, scale, periodic?, rational?, accumulation points, empty regions?, elementary, custom?
	- use images(self????) as transformations
	- vector fields
  - seed impulses
	- graphically outline seeds?
	- superformula - https://en.wikipedia.org/wiki/Superformula
  - for each pixel, define a normal vector, so we can do lighting & material effects
  - investigate dsl for scripts
  - webcam input

FUTURE:
  - test on ipad
  - test on android
	- unit tests
  - logging system
  - programming guidelines document - i.e make sure all tree modifications rebuild mod ref lib
  - benchmarking tools
  - image comparison testing

NO CLUE:
  - saving images loses bit depth??
  - weird divide by zero issue - glitch in content
  - maybe pixel alignment issues with images?







MATH:
  t_inner:z / (z + 1) + z / (z - 1)}
  zn [1.500 + 0.000i, 0.000 + 0.000i, 0.800 + 0.000i, 0.200 + 0.000i]
  creates a legitimate fractal
	I saw something that might explain it
