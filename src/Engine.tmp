module Engine where

import Prelude

initTex :: Int -> WebGL (Tuple WebGLTexture WebGLFramebuffer)
initTex dim = do
  ctx <- ask
  tex <- createTexture
  fb  <- createFramebuffer
  liftEff $ GL.bindTexture ctx GLE.texture2d tex
  liftEff $ GL.texParameteri ctx GLE.texture2d GLE.textureWrapS GLE.clampToEdge
  liftEff $ GL.texParameteri ctx GLE.texture2d GLE.textureWrapT GLE.clampToEdge
  liftEff $ GL.texParameteri ctx GLE.texture2d GLE.textureMinFilter GLE.linear
  liftEff $ GL.texParameteri ctx GLE.texture2d GLE.textureMagFilter GLE.linear
  liftEff $ GL.texImage2D_ ctx GLE.texture2d 0 GLE.rgba dim dim 0 GLE.rgba GLE.unsignedByte (unsafeNull :: GLT.ArrayBufferView)
  liftEff $ GL.bindFramebuffer ctx GLE.framebuffer fb
  liftEff $ GL.framebufferTexture2D ctx GLE.framebuffer GLE.colorAttachment0 GLE.texture2d tex 0

  return $ Tuple tex fb

type ProgData = { displayProg :: WebGLProgram, mainProg :: WebGLProgram, ts :: (Tuple WebGLTexture WebGLTexture) , fbs :: (Tuple WebGLFramebuffer WebGLFramebuffer) }

initWebGL :: Int -> WebGL ProgData
initWebGL dim = do
  ctx <- ask

  -- initialize shaders
  let basicVert   = getURL "/shaders/basic.vert.glsl"
  let mainFrag    = getURL "/shaders/main.frag.glsl"
  let displayFrag = getURL "/shaders/display.frag.glsl"

  mainProg    <- compileShadersIntoProgram basicVert mainFrag
  displayProg <- compileShadersIntoProgram basicVert displayFrag
  displayAttr <- getAttrBindings displayProg
  mainAttr    <- getAttrBindings displayProg

  -- -- initialize textures
  Tuple t0 fb0 <- initTex dim
  Tuple t1 fb1 <- initTex dim

  -- vertex coords
  pos <- createBuffer
  bindBuffer ArrayBuffer pos
  bufferData ArrayBuffer (DataSource (T.asFloat32Array [-1.0,-1.0,1.0,-1.0,-1.0, 1.0, -1.0,1.0,1.0,-1.0,1.0,1.0])) StaticDraw

  enableVertexAttribArray mainAttr.a_position
  vertexAttribPointer mainAttr.a_position 2 Float false 0 0
  enableVertexAttribArray displayAttr.a_position
  vertexAttribPointer displayAttr.a_position 2 Float false 0 0

  -- misc
  canvasWidth <- drawingBufferWidth
  canvasHeight <- drawingBufferWidth
  liftEff $ GL.viewport ctx 0 0 canvasWidth canvasHeight
  clearColor 0.0 0.0 0.0 1.0
  liftEff $ GL.clear ctx GLE.colorBufferBit
  return { displayProg: displayProg, mainProg: mainProg, ts: (Tuple t0 t1), fbs: (Tuple fb0 fb1) }


animate :: ProgData -> Int -> WebGL Unit
animate pd1 count = do
  ctx <- ask

  -- ping pong buffers
  let tm = if count `mod` 2 == 0 then fst pd1.ts else snd pd1.ts
  let td = if count `mod` 2 == 1 then fst pd1.ts else snd pd1.ts
  let fb = if count `mod` 2 == 1 then fst pd1.fbs else snd pd1.fbs
  pd <- if count `mod` 10 /= 0 then return pd1 else (initWebGL 1024)

  -- main program
  liftEff $ GL.useProgram ctx pd.mainProg
  liftEff $ GL.bindTexture ctx GLE.texture2d tm
  liftEff $ GL.bindFramebuffer ctx GLE.framebuffer fb

  mainUnif <- getUniformBindings pd.mainProg
  uniform1f mainUnif.kernel_dim 1024.0
  uniform1f mainUnif.time (toNumber count / 45.0)

  drawArrays Triangles 0 6

  -- display/post program
  liftEff $ GL.useProgram ctx pd.displayProg
  liftEff $ GL.bindTexture ctx GLE.texture2d td
  liftEff $ GL.bindFramebuffer ctx GLE.framebuffer unsafeNull

  displayUnif <- getUniformBindings pd.displayProg
  uniform1f displayUnif.kernel_dim 1024.0
  drawArrays Triangles 0 6

  liftEff $ requestAnimationFrame $ runWebgl (animate pd1 (count + 1)) ctx

handleGLError :: forall a eff. Either WebGLError a -> Eff (console :: CONSOLE | eff) e
handleGLError (Left er) = (log $ show er) >>= return
handleGLError (Right r) = return r
